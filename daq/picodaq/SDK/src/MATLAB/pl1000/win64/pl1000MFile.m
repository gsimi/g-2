function [methodinfo,structs,enuminfo,ThunkLibName]=pl1000MFile
%PL1000MFILE Create structures to define interfaces found in 'pl1000Api'.

%This function was generated by loadlibrary.m parser version 1.1.6.37 on Wed Jun 25 12:18:09 2014
%perl options:'pl1000Api.i -outfile=pl1000MFile.m -thunkfile=pl1000_thunk_pcwin64.c -header=pl1000Api.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'pl1000_thunk_pcwin64');
% PICO_STATUS pl1000OpenUnit ( int16_t * handle ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='pl1000OpenUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000CloseUnit ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='pl1000CloseUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000GetUnitInfo ( int16_t handle , int8_t * string , int16_t stringLength , int16_t * requiredSize , PICO_INFO info ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16voidPtruint32Thunk';fcns.name{fcnNum}='pl1000GetUnitInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int8Ptr', 'int16', 'int16Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000SetDo ( int16_t handle , int16_t do_value , int16_t doNo ); 
fcns.thunkname{fcnNum}='uint32int16int16int16Thunk';fcns.name{fcnNum}='pl1000SetDo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000SetPulseWidth ( int16_t handle , uint16_t period , uint8_t cycle ); 
fcns.thunkname{fcnNum}='uint32int16uint16uint8Thunk';fcns.name{fcnNum}='pl1000SetPulseWidth'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16', 'uint8'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000Run ( int16_t handle , uint32_t no_of_values , BLOCK_METHOD method ); 
fcns.thunkname{fcnNum}='uint32int16uint32BLOCK_METHODThunk';fcns.name{fcnNum}='pl1000Run'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'e_BLOCK_METHOD'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000Ready ( int16_t handle , int16_t * ready ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='pl1000Ready'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000Stop ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='pl1000Stop'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000MaxValue ( int16_t handle , uint16_t * maxValue ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='pl1000MaxValue'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000SetInterval ( int16_t handle , uint32_t * us_for_block , uint32_t ideal_no_of_samples , int16_t * channels , int16_t no_of_channels ); 
fcns.thunkname{fcnNum}='uint32int16voidPtruint32voidPtrint16Thunk';fcns.name{fcnNum}='pl1000SetInterval'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32', 'int16Ptr', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000SetTrigger ( int16_t handle , uint16_t enabled , uint16_t auto_trigger , uint16_t auto_ms , uint16_t channel , uint16_t dir , uint16_t threshold , uint16_t hysterisis , float delay ); 
fcns.thunkname{fcnNum}='uint32int16uint16uint16uint16uint16uint16uint16uint16floatThunk';fcns.name{fcnNum}='pl1000SetTrigger'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16', 'uint16', 'uint16', 'uint16', 'uint16', 'uint16', 'uint16', 'single'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000GetValues ( int16_t handle , uint16_t * values , uint32_t * noOfValues , uint16_t * overflow , uint32_t * triggerIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='pl1000GetValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16Ptr', 'uint32Ptr', 'uint16Ptr', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000GetTriggerTimeOffsetNs ( int16_t handle , int64_t * time ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='pl1000GetTriggerTimeOffsetNs'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int64Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000GetSingle ( int16_t handle , PL1000_INPUTS channel , uint16_t * value ); 
fcns.thunkname{fcnNum}='uint32int16PL1000_INPUTSvoidPtrThunk';fcns.name{fcnNum}='pl1000GetSingle'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPL1000Inputs', 'uint16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000OpenUnitAsync ( int16_t * status ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='pl1000OpenUnitAsync'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000OpenUnitProgress ( int16_t * handle , int16_t * progress , int16_t * complete ); 
fcns.thunkname{fcnNum}='uint32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='pl1000OpenUnitProgress'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS pl1000PingUnit ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='pl1000PingUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
enuminfo.enPL1000OpenProgress=struct('PL1000_OPEN_PROGRESS_FAIL',-1,'PL1000_OPEN_PROGRESS_PENDING',0,'PL1000_OPEN_PROGRESS_COMPLETE',1);
enuminfo.enPL1000DO_Channel=struct('PL1000_DO_CHANNEL_0',0,'PL1000_DO_CHANNEL_1',1,'PL1000_DO_CHANNEL_2',2,'PL1000_DO_CHANNEL_3',3,'PL1000_DO_CHANNEL_MAX',4);
enuminfo.enPL1000Inputs=struct('PL1000_CHANNEL_1',1,'PL1000_CHANNEL_2',2,'PL1000_CHANNEL_3',3,'PL1000_CHANNEL_4',4,'PL1000_CHANNEL_5',5,'PL1000_CHANNEL_6',6,'PL1000_CHANNEL_7',7,'PL1000_CHANNEL_8',8,'PL1000_CHANNEL_9',9,'PL1000_CHANNEL_10',10,'PL1000_CHANNEL_11',11,'PL1000_CHANNEL_12',12,'PL1000_CHANNEL_13',13,'PL1000_CHANNEL_14',14,'PL1000_CHANNEL_15',15,'PL1000_CHANNEL_16',16,'PL1000_MAX_CHANNELS',16);
enuminfo.e_BLOCK_METHOD=struct('BM_SINGLE',0,'BM_WINDOW',1,'BM_STREAM',2);
methodinfo=fcns;